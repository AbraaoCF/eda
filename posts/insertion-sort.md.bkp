+++
title = "Ordenação por Comparação: Insertion Sort"
date = 2019-10-27T01:01:01
tags = []
categories = []
github = ""
+++

***

# Direto ao ponto

O *Insertion Sort* tem como rotina base a inserção ordenada. A ideia é executar várias vezes essa rotina para ordenar um array. Para ser exato, se executarmos $N - 1$ vezes a rotina de inserção ordenada em um array o resultado é a ordenação completa do mesmo. Por isso, vamos antes entender como funciona inserção ordenada.

# Inserção ordenada

Vamos analisar o caso de um array com $N$ elementos no qual os $N - 1$ primeiros elementos estão ordenados, mas o último elemento não está no seu lugar. Isto é, precisamos encaixar o último elemento de forma que a sequência fique ordenada. No exemplo abaixo, estamos falando em inserir de forma ordenada o valor 12.

<p align="center">values =[9, 13, 16, 21, 32, <font color="red">12</font>]</p>

Como a sequência está ordenada até o penúltimo índice, a ideia é comparar 12 com o valor anterior e, se 12 for menor, trocar esses valores. Essas comparações e trocas só devem parar quando 12 for maior que o elemento à esquerda ou quando 12 estiver na primeira posição do array. Para visualizar esse algoritmo, alguns autores utilizam a metáfora de uma mão de cartas. Nesse contexto, o objetivo seria encaixar a carta 12 na mão já ordenada. Veja o passo a passo:

<p align="center">values = [9, 13, 16, 21, <font color="red">12</font>, 32]</p>
<p align="center">values = [9, 13, 16, <font color="red">12</font>, 21, 32]</p>
<p align="center">values = [9, 13, <font color="red">12</font>, 16, 21, 32]</p>
<p align="center">values = [9, <font color="red">12</font>, 13, 16, 21, 32]</p>

O código que implementa essa rotina está descrito abaixo. O índice `j` assume o valor inicial `values.length - 1` (última posição) e a condição de parada do laço é satisfeita quando esse índice alcançar 0 ou quando o valor que queremos inserir de forma ordenada já está na sua posição (`values[j] >= values[j-1]`). Se `j` alcançar 0, todo o array foi avaliado e o algoritmo deve parar. Da mesma forma, se `values[j] >= values[j-1]` o algoritmo deve parar porque o elemento que estamos querendo encaixar já está em seu lugar.

```java
...
	int j = values.lenght - 1;

	while (j > 0 && values[j] < values[j-1]) {
            int aux = values[j];
            values[j] = values[j-1];
            values[j-1] = aux;
            j -= 1;
    }
...
```
# Insertion Sort

A parte complexa desse algoritmo de ordenação nós já entendemos -- a inserção ordenada.

> O Insertion Sort aplica várias vezes a inserção ordenada para ordenar uma sequência. 

Vamos ver como isso é feito. 

Queremos ordenar $values = [7, 1, 2, 3, 9, 5, 1]$. Se pensarmos bem, podemos ver os dois primeiros elementos desse array como sendo o cenário apresentado na seção anterior, isto é, temos que $[7, 1]$ está ordenado, exceto pela última posição. Se aplicarmos inserção ordenada em $[7, 1]$, temos como resultado $[1, 7]$. 

Agora, vamos adotar a mesma postura com os três primeiros elementos: $[1, 7, 2]$. Novamente, podemos ver os 3 primeiros elementos como sendo o cenário para a inserção ordenada. Isto é $[1, 7, 2]$ está ordenado, exceto pelo último elemento. Se aplicarmos inserção ordenada em $[1, 7, 2]$, temos como resultado $[1, 2, 7]$.

Depois, vamos adotar a mesma postura com os quatro primeiros elementos: $[1, 2, 7, 3]$. Isto é, está ordenado, exceto pelo último elemento. Então basta aplicarmos inserção ordenada de 3. O resultado é $[1, 2, 3, 7]$.

Esse processo segue até o array ficar ordenado. Você percebeu que aplicamos inserção ordenada partindo do segundo elemento do array até o final? Isso significa que basta colocarmos um ***loop*** externo ao código de inserção ordenada, fazendo `j` variar de 1 até o último elemento. Vamos ao código:

```java
...
public static void insertionSort(int[] values) {
	for (int i = 1; i < values.length; i++) { 
		
		int j = i;
	
		while (j > 0 && values[j] < values[j-1]) {
			int aux = values[j];
			values[j] = values[j - 1];
			values[j - 1] = aux;
			j -= 1;
		}
	
	}	
}
...
```
A única mudança que fizemos foi adicionar o comando ***for*** com `i` variando de 1 até o final e `j` variando de acordo com `i`. 

Para fixar bem, veja a animação abaixo copiada <a class="external" href="https://medium.com/yay-its-erica/algorithms-for-beginners-bubble-sort-insertion-sort-merge-sort-29bd5506cc48"> deste material.</a> Note que a ideia é sempre inserir um elemento em uma sequência já ordenada.

![animacao](animacao.gif)

## Propriedades e Análise de eficiência

> O Insertion Sort é estável, in-place e $O(n^2)$.

O algoritmo é estável porque mantém a ordem relativa dos valores iguais. Isso porque as trocas são feitas sempre com vizinhos. Os valores vão sendo "afastados" um a um, e não dando saltos. Por isso, um elemento qualquer nunca trocará de posição com elementos de mesmo valor. 

O Insertion Sort é *in-place* porque a ordenação é feita rearranjando os elementos no próprio array, ao invés de usar arrays ou outras estruturas auxiliares.

O pior caso do Insertion Sort é um array ordenado em ordem reversa. 
<font color="red">TODO: incluir análise detalhada. Ver no cormen.</font>

É importante destacar que o Insertion Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas $O(n*\log n)$, como Quick Sort e Merge Sort, além de alternativas lineares como o <a class="external" href="https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/">Counting Sort</a>.



***

# Notas

Vale a pena utilizar o <a class="external" href="https://visualgo.net/en/sorting">VisuAlgo</a> para visualizar a execução do Insertion Sort e de outros algoritmos de ordenação. 

A implementação do Cormen é diferente.

<font color="red">Citar cormen.</font>