+++
title = "Ordenação por Comparação: Quick Sort"
date = 2019-10-27T00:01:01
tags = []
categories = []
github = ""
+++

***

Quick Sort é um algoritmo eficiente de ordenação. Seu funcionamento baseia-se em uma rotina fundamental cujo nome é ***particionamento***. Particionar significa escolher um número qualquer presente no array, chamado de ***pivot***, e colocá-lo em uma posição tal que todos os elementos à esquerda são menores e todos os elementos da direita são maiores ou iguais.

**Exemplo.** Vamos particionar o array $[3, 8, 7, 10, 0, 23, 2, 1, 77, 7]$. Saiba, não vou entrar em detalhes sobre como é feito o particionamento agora. Neste momento minha preocupação é que você saiba o que é particionar, não como. Então, vamos ver o estado do array antes e depois de particionar. Como disse, precisamos escolher um ***pivot***. Por ora, vamos sempre escolher o primeiro elemento do array. Ou seja, nosso ***pivot*** é o valor 3.

Antes do particionamento: [<font color="red">3</font>, 8, 7, 10, 0, 23, 2, 1, 77, 7]

Depois do particionamento: [1, 0, 2, <font color="red">3</font>, 8, 23, 7, 10, 77, 7 ]


Note que todos os elementos à esquerda do pivot são menores do que ele e todos os elementos à direita do pivot são maiores ou iguais a ele. Isso não significa que os elementos à esquerda e à direita devem necessariamente estar ordenados. Apenas significa que o ***pivot*** está em sua posição e o problema de ordenar agora resume-se a resolver a esquerda dele e a direita dele, concorda?

Antes disso, já que entendemos o que é particionamento, vamos agora ver como este algoritmo funciona. Há duas estratégias populares de particionamento: Lomuto e Hoare. Neste material nós vamos abordar a estratégia de Lomuto, que é mais simples. O particionamento Hoare é discutido em detalhes <a class="external" href="link">neste outro material</a>.

A ideia do particionamento de Lomuto é identificar os elementos menores do que o pivot e colocá-los imediatamente à frente dele. Depois, no final, coloca-se o pivot à frente deles todos. Vamos ver um exemplo concreto para ver como funciona essa ideia.

Para o array $values = [3, 8, 7, 10, 0, 23, 2, 1, 77, 7]$, temos que $pivot = 3$. Vamos iterar no array identificando os elementos menores. O primeiro identificado é o valor 0. 

<p align="center">values = [<font color="red">3</font>, 8, 7, 10, <font color="blue">0</font>, 23, 2, 1, 77, 7]</p>

Nosso trabalho agora é colocar o valor 0 à frente do pivot. Então, trocamos esse valor com o valor 8 (imediatamente à frente de 3). Note, no estado parcial, que 0 ficou à frente de 3 e 8 assumiu o índice de 0.

<p align="center">values = [<font color="red">3</font>, <font color="blue">0</font>, 7, 10, 8, 23, 2, 1, 77, 7]</p>

Acabou? Não. O próximo elemento menor que o pivot (3) é 2. 

<p align="center">values = [<font color="red">3</font>, <font color="blue">0</font>, 7, 10, 8, 23, <font color="blue">2</font>, 1, 77, 7]</p>

Temos que trazer 2 para a frente de 3. Vamos fazer isso trocando este valor com o valor 7. Veja, no estado parcial, que agora os valores 0 e 2 estão à frente de 3.

<p align="center">values = [<font color="red">3</font>, <font color="blue">0, 2</font>, 10, 8, 23, 7, 1, 77, 7]</p>

Acabou? Não. O próximo elemento menor que o pivot (3) é 1. 

<p align="center">values = [<font color="red">3</font>, <font color="blue">0, 2</font>, 10, 8, 23, 7, <font color="blue">1</font>, 77, 7]</p>

Temos que trazer 1 para a frente de 3. Vamos fazer isso trocando este valor com o valor 10. Veja, no estado parcial, que agora os valores 0, 2 e 1 estão à frente de 3.

<p align="center">values = [<font color="red">3</font>, <font color="blue">0, 2, 1</font>, 8, 23, 7, 10, 77, 7]</p>

E agora? Agora não há mais elementos menores do que o pivot para serem identificados. Todos os elementos menores (0, 2 e 1) estão imediatamente à frente dele. Então, basta trocarmos o pivot (3) com o último deles (1).

<p align="center">values = [<font color="blue">1, 0, 2</font>, <font color="red">3</font>, 8, 23, 7, 10, 77, 7]</p>

Feito. Agora 3 está em seu lugar, com todos os elementos menores à sua esquerda e os elementos maiores ou iguais à direita.

Então, agora sabemos o que é e como funciona o particionamento. Chegou a hora de analisar o código.

## Implementação do Particionamento de Lomuto

```java
...
    public static int particiona(int[] values, int ini, int fim) {
        
        int pivot = values[ini];
        int i = ini;

        for (int j = ini + 1; j <= fim; j++) {
            if (values[j] < pivot) {
                i+=1;
                swap(values, i, j);
            }
        }

        // troca pivot (values[ini]) com i.
        swap(values, ini, i);
        
        return i; 
    }
...
```

Em primeiro lugar, vamos entender a assinatura do método ***particiona***. Naturalmente, ele recebe como parâmetro o array a ser particionado. Recebe também dois índices válidos do array (`ini` e `fim`) que determinam os limites em que o algoritmo deve agir. Como o particionamento será usado dentro do contexto do Quick Sort, que é recursivo, precisamos controlar a faixa de valores em que o particiona será executado através destes índices. Claro, na primeira chamada, `ini = 0` e `fim = values.length - 1`.

A primeira linha do método é a escolha do pivot. Estamos sempre escolhendo o elemento no primeiro índice como o pivot, por isso temos `pivot = values[ini]`.

Depois, lembre-se, precisamos itererar sobre o array procurando os elementos menores e trocando-os com as posições à frente do pivot. Quem irá controlar a iteração é a variável `j`, enquanto `i` controla as trocas. Então, `j` varia sempre da segunda posição (`ini + 1`), pois não precisamos comparar o ***pivot*** com ele mesmo, até a última posição do array (`fim`). Enquanto isso, `i` começa na posição à frente do pivot `j+1` e só é incrementado se um novo valor menor for encontrado.

Quando um valor menor que o ***pivot*** for encontrado (`if values[j] < pivot`), efetuamos dois passos:

1. Incrementar `i`;
2. Trocar $values[i]$ por $values[j]$.

Repete comigo. Sempre que encontrarmos um valor menor que o ***pivot***, incrementamos `i` e trocamos $values[i]$ por $values[i]$.

Quando encerrar a iteração, basta agora trocar $values[i]$ pela posição do ***pivot***. Ou seja, trocamos $values[i]$ por $values[ini]$.

Por fim, retornamos `i`, que é a posição final do ***pivot***.

Para fixar bem, vamos ver um outro exemplo com figuras demonstrando o passo a passo.


# Quick Sort

Você concorda que após uma execução do ***particiona*** o ***pivot*** está em sua posição na sequência? 




